\chapter{First Order Logic (in construction)}
\label{chap:fol}

\section{Introduction}

This chapter is devoted to the presentation to  data structures for representing first order formulas over a ranked alphabet, and the basic functions and predicates over these types:

\begin{itemize}
\item Abstract syntax of terms and formulas over a ranked alphabet composed of function and relation symbols.
\item Induction principles over terms and formulas.
\item Definition and main properties of substitution of terms to variables.
\end{itemize}




Although all the following constructions come directly from~\cite{Goedel}, we introduced minor changes (mainly syntax) to
take into account recent changes in \coq(new constructions, tactics, notations, etc.).


\section{Data types}

\subsection{Languages}

A \emph{language} is a structure composed of relation and function symbols, each symbol is given an \emph{arity} (number of arguments)\,\footnote{As suggested by Russel O'Connor in~\cite{OConnor05}, we consider two arity functions instead of a single function defined on the sum type \texttt{Relations + Functions}.}.

From~\href{../theories/html/hydras.Ackermann.fol.html}{Ackermann.fol}
\inputsnippets{fol/LanguageDef} 


\subsubsection{Example: a toy language}
In order to show a few simple examples of statements and proofs, we define a small language with very few symbols:
two constant symbols: $a$ and $b$, three function symbols $f$, $g$ and $h$  (of respective arity 1, 1 and 2), three propositional symbols $A$, $B$ and $C$, a one-place predicate symbol $P$, and a binary relational symbol $R$. 
 
From~\href{../theories/html/hydras.MoreAck.FolExamples.html}{MoreAck.FolExamples}.

\inputsnippets{FolExamples/ToyDef}

\begin{remark}
  \label{rem:underscores}
  The constructors of types \texttt{Rel} and \texttt{Fun} are suffixed by an underscore, in order to reserve the names \texttt{a}, \texttt{f}, \texttt{h}, \texttt{R}, etc. to functions which build terms and formulas (please look at Sect~\ref{sec:fol-term-notations} and \ref{sec:fol-atomic-notations}).
\end{remark}


\subsection{Terms}

Given a language $L$, we define the type of \emph{terms} and
$n$-\emph{tuples of terms} over $L$.

\inputsnippets{fol/TermDef} 

\begin{remark}
This representation of terms uses mutually inductive data-types instead of list of terms. Please see also Remark~\ref{hydra:mutually-inductive-vs-lists}.
\end{remark}


\begin{remark}[Variables]
In O'Connor's formalization of first-order logic,  variables are 
just natural numbers, and the \emph{coercion} from
\texttt{nat} to \texttt{Term L} is the constructor (\texttt{@var $L$}).
Although other choices may be considered : PHOAS, de Bruijn indices, etc,  we still the data structures of~\cite{Goedel}, in order not to break long proof scripts which use this representation (please look at \cite{OConnor05} for a related discussion).
  
\end{remark}




\subsubsection{Examples}
\label{sect:folTermExamples}


Let us define some \gallina terms over our toy language, respecively corresponding to the terms $a$,
$f(a)$, and $h(f(a),a)$.

First, in order to make terms on $L$ more readable, we introduce a few abbreviations.


From~\href{../theories/html/hydras.MoreAck.FolExamples.html}{MoreAck.FolExamples}.

\inputsnippets{FolExamples/termAbbreviations}

\inputsnippets{FolExamples/TermExamples1} 

\begin{remark}
The fourth ``term'' \texttt{t4} is not well formed, since the arity of $h$ is not respected\,\footnote{Strictly speaking, it's not a (well typed) term!}.
\end{remark}

\subsubsection{Other Languages}

\begin{todo}
Link to the chapter which presents \texttt{LNT} and \texttt{LNN}.
\end{todo}

\subsection{First-order formulas}



The type of first order formulas over $L$ is defined 
in~\href{../theories/html/hydras.Ackermann.fol.html}{Ackermann.fol} as an inductive data type.

\inputsnippets{fol/FormulaDef}


Structural induction/recursion principles are generated by 
\texttt{Formula}'s definition, for instance:

\inputsnippets{FolExamples/FormulaRect}

\begin{remark}
The type \texttt{Formula} (over $L$) has only five constructors,
respectively associated with term equalities $t_1=t_2$, atomic formulas of the form $(r\;t_1\;\dots\;t_n)$, implications $(F \arrow G)$, negations $({\sim}F)$, and universal quantifications $(\forall\,i, F)$.  

In~\cite{Goedel}, no \emph{constructors} of type \texttt{(Formula L)} are associated with
disjunction, conjonction, logical equivalence and existential quantifier. These constructs are formalized through \emph{definitions}\footnote{Please keep in mind that we are considering a classical logic.}.

\inputsnippets{fol/FolFull, fol/folPlus}

This convention allows the user to reduce to 5 (instead of 10) the number of cases in ''\texttt{match F with \dots}'' constructs. On the other hand, some computation may expand a connective like $\vee$ or
$\wedge$, or an existential quantification into a ``basic'' formula (see Sect.\vref{sect:fol-issue}).
\end{remark}

\subsection{Examples}




Let us give a few examples of first-order formulas over $L$.
\label{fol:examplesf1f2f3}
\begin{description}
\item[F1] $R\;a\;b$
\item[F2] $\forall v_0\; v_1, R\;v_0\;v_1 \arrow R\;v_1\;v_0$
\item[F3] $ \forall v_0, v_0=a \vee \exists\;v_1,\, v_0= f(v_1)$
\item[F4] $(\forall v_1, v_0 = v_1) \vee \exists\,v_0\,v_1, v_0 \not= v_1$
\item[F5] $v_0 =a \vee v_0 = f(v_1)$
 \item[F6] $\forall v_0,\,\exists v_1, v_0= f(v_1)\wedge v_0\not= v_1$
\end{description}

Let us now define these formulas as terms of type
\texttt{(Formula L)}.

First, we define abbreviations for atomic formulas over $L$.

\noindent From~\href{../theories/html/hydras.MoreAck.FolExamples.html}{MoreAck.FolExamples}

\inputsnippets{FolExamples/toyNotationForm}

\label{sec:fol-atomic-notations}
\label{sect:folFormExamples}

\inputsnippets{FolExamples/FormExamples}


% The following interactions show how the formulas 
% of~\ref{sect:folFormExamples} may be 
% parsed or printed. 

% \noindent From~\href{../theories/html/hydras.MoreAck.FolExamples.html}{MoreAck.FolExamples}

% \vspace{6pt}

% \inputsnippets{FolExamples/toyNotationForm2}








\subsubsection{Bound variables}

In~\cite{Goedel}, there is no De Bruijn encoding of bound variables (see also~\cite{OConnor05}).

For instance, the the  term \texttt{(var 0)}
occurs freely and also inside the scope of a quantifier in the
formula \texttt{F4} \vpageref[above]{sect:folFormExamples}.

The following example shows two formulas which share the same structure, are logically equivalent, but are not Leibniz equal.



\vspace{4pt}

\noindent From~\href{../theories/html/hydras.MoreAck.FolExamples.html}{MoreAck.FolExamples}
  
\inputsnippets{FolExamples/boundVars}  

I

  \begin{todo}
   Link to the lemmas which attest the equivalence of these formulas (properties of substitution, logical equivalence).
  \end{todo}


  \index{ackermann}{Projects}
  \begin{project}
 Use a HOAS representation for FOL terms and formulas (without breaking proof scripts).   
  \end{project}



\section{A notation scope for first-order terms and formulas}
\label{sect:fol-notations}


 We use \coq's \texttt{Notation} features to print and parse terms and formulas  in a more readable form.
To this purpose, we build \texttt{fol\_scope}, a  notation scope
where the main connectives and quantifiers get a syntax close to \coq's.  Additionnally, a term of the form \texttt{(@var \_ $i$)} is
just printed and parsed  \texttt{v\#$i$}.

\inputsnippets{fol/folScope1}


The \texttt{\%fol} delimiter 
allows the user to distinguish \texttt{FOL} connectives from their \coq equivalent.
\emph{We discourage the reader from \emph{opening} \texttt{fol\_scope} and similar scopes : \texttt{nn\_scope}, \texttt{nt\_scope}, which would make disappear the \texttt{\%fol} suffix from the first-order formulas}.


\vspace{6pt}

\noindent From \href{../theories/html/hydras.Ackermann.fol.html}{Ackermann.fol}

\inputsnippets{FolExamples/toyNotationForm2}


\subsection{The issue with derived constructions}
\label{sect:fol-issue}


The connectives and quantifiers $\vee$, $\wedge$, $\exists$, etc. may raise an issue when printing computed formulas.
For instance, a formula like $F \wedge G$ could be transformed into $\sim(\sim F \vee \sim G)$,  and even
into $\sim(\sim\sim F \arrow \sim B)$, which would 
cause serious problems of readability.

In such a case, we propose to print such a formula as $F \wedge' G$, to make it syntactically distinct but very similar to $F \wedge G$.

\inputsnippets{fol/folScope2}

The following examples show how the primed connectors 
and quantifiers behave with respect to convertibility and 
input/output.



 \inputsnippets{FolExamples/toyNotationForm3}


\inputsnippets{FolExamples/toyNotationForm4}









\section{Computing and reasoning on first-order formulas}



\subsection{Decidability of equality}
% Deciding whether two formulas are equal is a part of the verification of a proof (for instance in the implementation of the \emph{assumption} rule).

Let $L$ be a language, and let us assume that equality 
of function and relation symbols of $L$ are decidable.
Under this assumption, equality of terms and formulas over $L$ is decidable too.

Because of dependent types, the proofs are quite long and technical. The reader may consult them in \href{../theories/html/hydras.Ackermann.fol.html}{Ackermann.fol}



\inputsnippets{fol/formDec1, fol/formDec2,
fol/formDec3,fol/formDec4,fol/formDec5}


\begin{remark}
Please note that \texttt{term\_dec}, \texttt{terms\_dec} and
\texttt{formula\_dec} are \emph{opaque}. 

The function \texttt{formula\_dec} is mainly used in
\href{../theories/html/hydras.Ackermann.PA.html}{Ackermann.PA}, in order to check whether a given formula belongs to the axioms of Peano arithmetic.
\begin{todo}
  Look for the use of \texttt{open}  (in codePA)
\end{todo}

\end{remark}

\subsection{Variables and substitutions}

Since free and bound occurrences of a variable $i$ are represented the same way, much care should be taken in programming the substitution of a term to a variable in order to avoid \emph{variable capture}.

For instance let $F$ be the formula 
$\exists v_2, v_1 \not= f(v_2)$. The result of the substitution 
of the term $f(v_2)$ to the (free) occurrences of $v_1$ in $F$
 \emph{is not} $\exists v_2, f(v_2) \not= f(v_2)$, but, for instance $\exists v_3, f(v_2) \not= f(v_3)$, where $v_3$ is a ``fresh'' variable.


\inputsnippets{FolExamples/substExample1}
\inputsnippets{FolExamples/substExample2}

From this little example, we can guess that the function
\texttt{substF} which is assumed to compute the substitution in a formula $F$ the substitution of a term $t$ to the free occurrences of a variable $v$ will not be implemented as a direct structural recursive function. For instance, the formula $G$, obtained through a variable renaming, is not a strict subterm of $F$.

To fix this issue, we can associate  a measure (\emph{e.g.} a natural number) to each formula, such that the renaming of a strict subformula $F$ is strictly smaller that $F$. 



\subsubsection{Depth of a formula}

The function \texttt{depth} computes the \emph{depth} of the 
 skeleton of any formula, and allows us to define a well-founded strict order on 
\texttt{Formula $L$}.

\inputsnippets{fol/depthDef,  FolExamples/DepthCompute}

\subsubsection{Induction on depth}

\inputsnippets{FolExamples/ltDepth1}


\begin{todo}
Motivate the induction principles based on depth. Compatible with term substitution and universal quantifier elimination.
\end{todo}



\inputsnippets{FolExamples/depthRecDemo}

\begin{todo}
 Look for the principles which are really used in Ackermann or/and Goedel libraries, and comment them.
 Maybe skip the helpers (unused in other files)
\end{todo}

The library~\href{../theories/html/hydras.Ackermann.fol.html}{Ackermann.fol} contains several induction principles, applied 
throughout \texttt{Ackermann} and \texttt{Goedel} projects.


Let us for instance have a look  at \texttt{Formula\_depth\_ind2}. Its application in order to prove $P\;a$ generates 5 sub-goals. 

\inputsnippets{FolExamples/depthRecDemo2}

\begin{itemize}
\item Goals $1$ to $4$ correspond to  usual proofs by structural induction.
\item Goal $5$ is associated with a universal quantification $f=\forall\,v,a$. In this case, we have to prove that $P\;b$ holds for any formula $b$ which has a depth strictly less than $f$. Such a $b$ may for instance the result of replacing the free occurrences of $v$ in $a$ with any term $t$.
  \begin{todo}
   Make a link to an appropriate example.
  \end{todo}
\end{itemize}



\subsection{Free variables and substitutions}

\begin{todo}
Link to folProp.v
\end{todo}


 
Section \texttt{Free\_Variables} 
of~\href{../theories/html/hydras.Ackermann.fol.html}{Ackermann.fol} defines the list of free variables which occur in a term (respectively in a formula).

We advise the reader to look at these functions, and limit ourselves to give a few examples.

Let us consider again the formulas \texttt{f3} and \texttt{f4} of page~\pageref{fol:examplesf1f2f3}.

The list of free variable occurrences of a formula is given by the function \texttt{freeVarFormula}. The function \texttt{close}
binds all the free variables of a formula with universal quantifiers.

\inputsnippets{FolExamples/freeVarExamples}

\subsection{Multiple substitutions}

\begin{todo}
Link to subAll.v
\end{todo}

\begin{todo}
Make a chapter!
\end{todo}
\section{Languages for Arithmetic}



Two languages built with the usual symbols of arithmetic are 
defined in ~\href{../theories/html/hydras.Ackermann.Languages.html}{Ackermann.Languages}.

\begin{itemize}
\item The first language: \texttt{LNT} (\emph{Language of Number Theory}) has just function symbols for $+$, $\times$, $0$ and successor.
\item The second language: LNN (\emph{Language of Natural Numbers})  has
the same function symbols as LNT plus one relation symbol for the strict inequality $<$ : \texttt{LT} (less than).
\end{itemize}

\subsubsection{Language of Number Theory (LNT)}

First, we declare two alphabets.

\inputsnippets{Languages/LNTDef1} 

In a second time, we build \texttt{LNT} and \texttt{LNN} by filling \texttt{Language}'s \texttt{arity} field.

\inputsnippets{Languages/LNTDef2} 

\begin{remark}
  We depart a little from \cite{Goedel}'s notations, where the 
function and relation symbols are called \texttt{Plus}, 
\texttt{Mult}, \texttt{LT}, etc. In our version, these type constructors are called \texttt{Plus\_}, 
\texttt{Mult\_}, \texttt{LT\_}, etc., while the names without final underscores are bound to term building functions (\emph{e.g.}
the function which takes two terms and builds the term representing their sum) (see Remark~\ref{rem:underscores}).
\end{remark}


\subsubsection{Language of Natural Numbers (LNN)}

\texttt{LNN} is an extension of \texttt{LNT}, by the addition 
of the $<$ relation symbol.


\inputsnippets{Languages/LNNDef}



\subsubsection{Examples}

Let us show a few examples (from ~\href{../theories/html/hydras.MoreAck.FolExamples.html}{MoreAck.FolExamples}).

\inputsnippets{FolExamples/arityTest} 
 



% \subsubsection{Examples}

% With our toy language, we can build the following terms, respectively written $a$, $f(a)$ and $f(f(v_1))$ in usual mathematical notation. 

% Writing these terms in bare \gallina syntax would result in quite clumsy scripts. Thus, we may use a still experimental notation scope which allows us to write/print terms and formulas in a 
% notation similar to \coq's.





% We put both the associated \coq{} terms, in bare \gallina{} syntax, and with a still experimental and provisional notation, defined in
% ~\href{../theories/html/hydras.Ackerm.FOL_notations.html}{MoreAck.FOL\_notations}).



% \inputsnippets{FolExamples/toyNotation}

% \inputsnippets{FolExamples/smallTerms}


For instance the term $v_1+0$, where $v_1$ is a variable,
is represented by the following \gallina term of type 
(\texttt{fol.Term LNT}).

\inputsnippets{FolExamples/v1Plus0} 






\inputsnippets{LNN/instantiations}

\section{Notations for Formulas (experimental)}

In order to get more readable terms and formulas, we can define a few notations in ~\href{../theories/html/hydras.MoreAck.FOL_notations.html}{MoreAck.FOL\_notations} and
~\href{../theories/html/hydras.MoreAck.LNN.html}{MoreAck.LNN}.
Please note that these notation scopes are experimental: We are going to use them in examples and exercises before using them in large original proof scripts (in the \texttt{ordinals/Ackermann/} sub-directory).

We try to define notation scopes as close as possible to \coq's syntax for propositions.

Let us take for instance the following proposition (in math form):

$$\forall\, v_0,\, v_0=0\vee \exists\,v_1,\,v_1=1+v_0$$

Here is a definition, using directly the \texttt{goedel/Ackermann}'s project syntax.

\inputsnippets{LNN_Examples/uglyF0}

Note that, because of redefinitions, the disjonction \texttt{orH}
can be expanded in terms of  implication and negation (for instance when we use \texttt{Compute}).

\begin{todo}
  Present the general issue about evaluation, and our provisional solution.
\end{todo}


\inputsnippets{LNN_Examples/CNNF0}




\section{Proofs}

\subsection{Contexts as lists}
\begin{todo}
Describe the \texttt{Prf} type (from \texttt{folProof.v}).

Give examples in a toy language.

Give an example which motivates \texttt{SysPrf}:

$P,P , P\arrow P \arrow Q, \vdash Q$ ?
\end{todo}

\begin{exercise}

Prove the following lemma:
\inputsnippets{FolExamples/eqRefl}

\end{exercise}

\subsection{Contexts as sets}

\begin{exercise}

Prove the following lemma:
\inputsnippets{FolExamples/MPdiag}

\end{exercise}


\section{Derived rules and natural deduction}


 The library 
 \href{../theories/html/hydras.Ackermann.folLogic.html}{Ackermann.folLogic} contains many derived rules which allow the user to build proofs in a natural deduction style (with introduction and elimination rules).

\subsection{Example}

For instance, let us prove Peirce's rule.
 (in  ~\href{../theories/html/hydras.MoreAck.FolExamples.html}{MoreAck.FolExamples} ).

\subsubsection{Prelude}

%\inputsnippets{folPeirce/prelude}


\subsection{Proof of Peirce's law}


\inputsnippets{FolExamples/PeirceProof}

Let us try to do an implication introduction.

\inputsnippets{FolExamples/step1}

Now, we may use the law of excluded middle with the formula $P$. The only non-trivial case is about $\sim P$.

\inputsnippets{FolExamples/step2}

The rest of the proof is composed of basic proof steps, 
and bookkeeping steps (about \texttt{Ensembles.In}).

\inputsnippets{FolExamples/step3, FolExamples/step4}

\index{ackermann}{Exercises}
\begin{exercise}
Prove, using the rules described in 
 \href{../theories/html/hydras.Ackermann.folLogic.html}{Ackermann.folLogic}, the famous \emph{drinkers theorem}:

$$\exists\,x,\; (D(x)\Longrightarrow \forall\,y,\; D(y))$$
\end{exercise}

where $D$ (for ``drinks'') is some predicate symbol of arity $1$.


